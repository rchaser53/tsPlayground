// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/42ce1506a3943be47e0e421e39c35f552c0cdf3a/react-redux/react-redux.d.ts

declare namespace ReduxLogic {
	import __Redux = Redux;
	
	interface temp {
		httpClient: Function;
		getState: Function;
		action: Function;
		cancelled$?: Function;
	}

	export interface logicOption<T> {
		// required string, regex, array of str/regex, use '*' for all
		type: string;
		
		// string, regex, array of strings or regexes
		cancelType: string; 
		// type and cancelType also support redux-actions fns for which
		// the fn.toString() returns the associated action type
		// limiting - optionally define any of these
		
		// debounce for N ms, default 0
		debounce?: number;
		
		// throttle for N ms, default 0
		throttle?: number;
		
		// only take latest, default false
		latest: boolean;

		// Put your business logic into one or more of these
		// execution phase hooks: validate, transform, process


		// Note: If you provided any optional dependencies in your
		// createLogicMiddleware call, then these will be provided to
		// your code in the first argument along with getState and action
		// See advanced section for more details
		// validate({ getState, action }, allow, reject) {
		// 	// run your verification logic and then call allow or reject
		// 	// with the action to pass along. You may pass the original action
		// 	// or a modified/different action. Use undefined to prevent any
		// 	// action from being propagated like allow() or reject()
		// 	// If reject is used then the process hook will not be executed
		// 	allow(action); // OR reject(action)
		// });

		validate?: (validateObj: dependency, allow: Function, reject: Function ) => void;

		// Note: transform is just an alias for the validate hook (next = allow)
		// to communicate clearer intent, you can do the same things in either
		// transform({ getState, action }, next /*, reject */) {
		// 	// perform any transformation and provide the new action to next
		// 	next(action);
		// });
		transform?:(validateObj: dependency, next: Function) => void;

		// options influencing the process hook, defaults to {}
		processOptions?: {
			// dispatch return value, or if returns promise/observable, dispatch resolved/next values
			dispatchReturn: boolean; // default false

			// string or action creator fn wrapping dispatched value
			successType?: string | any; // default undefined

			// string or action creator fn wrapping dispatched, rejected, or thrown errors
			failType?: string | any; // default undefined
			// failType?: string | __Redux.ActionCreator<A>; // default undefined
		};

		// If validate/transform reject was used then this hook will not be
		// executed. Call dispatch exactly once or read the advanced api about
		// performing multiple dispatches

		// process({ getState, action, cancelled$ }, dispatch) {
		// 	// Perform your processing then call dispatch with an action
		// 	// or use dispatch() to complete without dispatching anything.
		// 	// Multi-dispatch: see advanced API docs
		// 	dispatch(myNewAction);
		// })
		process:<T>(validateObj: dependency, dispatch: __Redux.Dispatch<T>) => void;
	}


	export function createLogic<T>(option: logicOption<T>): somethingLogic;

	interface somethingLogic {}

	type poyo = 'aaa' | 'bbb' | 'httpClient';

	export interface dependency{
		[key:string] : any;
	}

	export function createLogicMiddleware(logic: somethingLogic[], deps: dependency) : __Redux.Middleware;

}

declare module "redux-logic" {
	export = ReduxLogic;
}
